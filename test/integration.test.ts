import { describe, it, expect } from 'vitest';
import { mkdtemp, rm, writeFile, mkdir } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { generate } from '../src/tywrap.js';
import { processUtils, fsUtils } from '../src/utils/runtime.js';
import { NodeBridge } from '../src/runtime/node.js';
import { getDefaultPythonPath } from '../src/utils/python.js';

/**
 * IR-only Integration Tests
 */
const isCi =
  ['1', 'true'].includes((process.env.CI ?? '').toLowerCase()) ||
  ['1', 'true'].includes((process.env.GITHUB_ACTIONS ?? '').toLowerCase()) ||
  ['1', 'true'].includes((process.env.ACT ?? '').toLowerCase());
const nodeBridgeTimeoutMs = isCi ? 60000 : 30000;
const nodeBridgeTestTimeoutMs = isCi ? 60000 : 30000;
const defaultPythonPath = getDefaultPythonPath();

describe('IR-only integration', () => {
  it('tywrap_ir emits JSON IR for math', async () => {
    const result = await processUtils.exec(defaultPythonPath, [
      '-m',
      'tywrap_ir',
      '--module',
      'math',
      '--no-pretty',
    ]);
    expect(result.code).toBe(0);
    const json = JSON.parse(result.stdout);
    expect(json.module).toBe('math');
    expect(Array.isArray(json.functions)).toBe(true);
  });

  it('generate() writes TS for math and contains wrappers', async () => {
    const outDir = './generated';
    const res = await generate({
      pythonModules: { math: { runtime: 'node', typeHints: 'strict' } },
      output: { dir: outDir, format: 'esm', declaration: false, sourceMap: false },
      runtime: { node: { pythonPath: defaultPythonPath } },
      performance: { caching: false, batching: false, compression: 'none' },
      development: { hotReload: false, sourceMap: false, validation: 'none' },
    } as any);
    expect(res.written.some(p => p.endsWith('math.generated.ts'))).toBe(true);
    const content = await fsUtils.readFile(`${outDir}/math.generated.ts`);
    expect(content).toContain('Generated by tywrap');
    expect(content).toContain('export async function');
    expect(content).toContain("getRuntimeBridge().call('math', 'sqrt'");
  });

  it('supports local Python modules via pythonImportPath', async () => {
    const tempDir = await mkdtemp(join(tmpdir(), 'tywrap-pythonImportPath-'));
    try {
      const importDir = join(tempDir, 'py');
      await mkdir(importDir, { recursive: true });
      await writeFile(
        join(importDir, 'local_module.py'),
        `def add(a: int, b: int) -> int:\n  return a + b\n\n# Should be excluded by default export filtering\ndef dataclass(x):\n  return x\n`,
        'utf-8'
      );

      const outDir = join(tempDir, 'generated');
      const res = await generate({
        pythonModules: { local_module: { runtime: 'node', typeHints: 'strict' } },
        pythonImportPath: [importDir],
        output: { dir: outDir, format: 'esm', declaration: false, sourceMap: false },
        runtime: { node: { pythonPath: defaultPythonPath } },
        performance: { caching: false, batching: false, compression: 'none' },
        development: { hotReload: false, sourceMap: false, validation: 'none' },
      } as any);

      expect(res.written.some(p => p.endsWith('local_module.generated.ts'))).toBe(true);
      const content = await fsUtils.readFile(join(outDir, 'local_module.generated.ts'));
      expect(content).toContain('local_module');
      expect(content).toContain('add');
      expect(content).not.toContain("call('local_module', 'dataclass'");
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  }, 30_000);
});

describe('NodeBridge smoke', () => {
  it(
    'calls math.sqrt',
    async () => {
      const bridge = new NodeBridge({
        scriptPath: 'runtime/python_bridge.py',
        timeoutMs: nodeBridgeTimeoutMs,
      });
      const result = await bridge.call<number>('math', 'sqrt', [9]);
      expect(result).toBe(3);
      await bridge.dispose();
    },
    nodeBridgeTestTimeoutMs
  );
});
